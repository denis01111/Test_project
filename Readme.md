***Its a my first HW on VSC***

# **Инструкция по работе с Git**
1. Введение
2. Базовые команды
3. Прочие команды
4. Основы работы с удалённым репозиторием

## **Введение** 
**Git** — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в *Git* эквивалент игрового сохранения — коммит). 

*Принцип работы:*
![firstPuctire](/files/first_pic.png)
![secondPicture](/files/sex_pic.png)

## **Базовые команды** 
Команды, без которых невозможно обойтись в разработке 

>- **git init** - создание репозитария 

Команда git init создает в директории пустой репозитарий в виде директория
.git, где и будет в дальнейшем храниться вся информация об истории коммитов,
тегах — ходе разработки проекта.

>- **git add и git rm** - индексация изменений

Команда **git add** позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит. Из индекса и дерева одновременно проекта файл можно удалить командой **git rm**.
Сбросить весь индекс или удалить из него изменения определенного файла можно
командой **git reset**.

>- **git status** - состояние проекта, измененные и не добавленные файлы, индексированные файлы.

Команда **git status**, пожалуй, можно считать самой часто используемой наряду с
командами коммита и индексации. Она выводит информацию обо всех изменениях,
внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей
ветки; отдельно выводятся внесенные в индекс и неиндексированные
файлы.

>- **git commit** - совершение коммита.

Коммиты — базовое понятие во всех системах контроля версий, поэтому совершатся
он должен легко и по возможности быстро. 
Подробнее о самой важной функции под спойлером. 
<details>

***<summary>Тыкни спойлер</summary>***

Есть несколько ключей, упрощающих работу с **git commit**:

**git commit -a** — совершит коммит, автоматически индексируя изменения в файлах
проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов
будет учтено.


**git commit -m «commit comment»** — комментируем коммит прямо из командной строки
вместо текстового редактора.

**git commit FILENAME** — внесет в индекс и создаст коммит на основе изменений
единственного файла.
</details>
  <br />

>- **git reset** - возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий».

Помимо работы с индексом (см. выше), **git reset** позволяет сбросить состояние
проекта до какого-либо коммита в истории. В git данное действие может быть двух
видов: «мягкого»(soft reset) и «жесткого» (hard reset).

*«Мягкий»* (с ключом **"--soft"**) резет оставит нетронутыми ваши индекс и все дерево
файлов и директорий проекта, вернется к работе с указанным коммитом. Иными
словами, если вы обнаруживаете ошибку в только что совершенном коммите или
комментарии к нему, то легко можно исправить ситуацию.

**git commit -c ORIG_HEAD** — вернутся к последнему коммиту, будет предложено
редактировать его сообщение. Если сообщение оставить прежним, то
достаточно изменить регистр ключа -с:

 **git commit -C ORIG_HEAD**

Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку
последнего коммита». Подробней описан синтаксис такой относительной адресации
будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно,
HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета
указывает на оригинальный коммит.

*«Жесткий» резет* (ключ --hard) — команда, которую следует использовать с
осторожностью. **Git reset --hard** вернет дерево проекта и индекс в состояние,
соответствующее указанному коммиту, удалив изменения последующих коммитов.

**git reset --hard HEAD~1** — больше никто и никогда не увидит этот коммит.

**git reset --hard HEAD~3** — три последних коммита. 

>- **git revit** - отмена изменений, произведенных в прошлом отдельным коммитом.

**git revert 12abacd** — отменяем коммит, используя его хэш.

Для использования команды необходимо, чтобы состояние проекта не отличалось от
состояния, зафиксированного последним коммитом.

>- **git log** - разнообразная информация о коммитах в целом, по отдельным файлам и различной глубины погружения в историю.

Иногда требуется получить информацию об истории коммитов, коммитах, изменивших
отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих
целей используется команда git log.

>- **git diff** - отличия между деревьями проекта; коммитами; состоянием индекса и каким-либо коммитом.

Своего рода подмножеством команды **git log** можно считать команду **git diff**,
определяющую изменения между объектами в проекте: деревьями (файлов и
директорий):

**git diff** — покажет изменения, не внесенные в индекс.

**git diff --cached** — изменения, внесенные в индекс.

Можно сравнивать «головы» веток:

**git diff master..experimental**

Ну или активную ветку с какой-либо:

**git diff experimental**

>- **git show** - показать изменения, внесенные отдельным коммитом

>- **git blame и git annotate** — вспомогательные команды, помогающие отслеживать изменения файлов

>- **git grep** - поиск слов по проекту, состоянию проекта в прошлом

**git grep tst** — поиск слова tst в проекте.

**git grep -с tst** — подсчитать число упоминаний tst в проекте.

**git grep -e 'first' --and -e 'another'** — найти строки, где упоминаются и первое слово, и второе.

 <br />

## **Ветвление**
 <br />

>- **git branch** - создание, перечисление и удаление веток

Работа с ветками — очень легкая процедура в git, все необходимые механизмы
сконцентрированы в одной команде:

**git branch** — просто перечислит существующие ветки, отметив активную.

**git branch new-branch** — создаст новую ветку new-branch.

**git branch -d new-branch** — удалит ветку, если та была залита (merged) с
разрешением возможных конфликтов в текущую.

>- **git checkout** — переключение между ветками, извлечение отдельных файлов из истории коммитов.
Команда **git checkout** позволяет переключаться между последними коммитами (если
упрощенно) веток.

**git checkout somefile** — вернуть *somefile* к состоянию последнего коммита.

>- **git merge** — слияние веток (разрешение возможных конфликтов).

Слияние веток, в отличие от обычной практики централизованных систем, в git
происходит практически каждый день. Естественно, что имеется удобный интерфейс к
популярной операции:

**git merge new-feature** — попробует объединить текующую ветку и ветку new-feature.

>- **git rebase** — построение ровной линии коммитов.

В принципе, можно обойтись обычным **git merge**. Но тогда усложняется сама линия
разработки, что бывает нежелательно в слишком больших проектах, где участвует
множество разработчиков.

Предположим, имеется две ветки, **master** и топик, в каждой из которых было совершенно несколько коммитов начиная с момента ветвления.
Команда **git rebase** берет коммиты из ветки **topic и** накладывает их на последний коммит ветки **master**:

**git-rebase master topic** — вариант, в котором явно указывается, что и куда
прикладывается.
**git-rebase master** — на **master** накладывается активная в настоящий момент
ветка.

>- **git cherry-pick** — применение к дереву проекта изменений, внесенных отдельным коммитом

Если ведется сложная история разработки, с несколькими длинными ветками
разработками, может возникнуть необходимость в применении изменений, внесенных
отдельным коммитом одной ветки, к дереву другой (активной в настоящий момент).

**git cherry-pick BUG_FIX_TAG** — изменения, внесенные указанным коммитом будут
применены к дереву, автоматически проиндексированы и станут коммитом в активной
ветке.

**git cherry-pick BUG_FIX_TAG -n** — ключ "-n" показывает, что изменения надо
просто применить к дереву проекта без индексации и создания коммита.
 
 <br />

## **Прочие команды и необходимые возможности**
 <br />

### Хэш — уникальная идентификация объектов
 <br />

В **git** для идентификации любых объектов используется уникальный (то есть с
огромной вероятностью уникальный) хэш из 40 символов, который определяется
хэшируюшей функцией на основе содержимого объекта. Объекты — это все: коммиты,
файлы, тэги, деревья. Поскольку хэш уникален для содержимого, например, файла,
то и сравнивать такие файлы очень легко — достаточно просто сравнить две строки
в сорок символов.
<br />
Больше всего нас интересует тот факт, что хэши идентифицируют коммиты. В этом
смысле хэш — продвинутый аналог ревизий Subversion. Несколько примеров
использования хэшей в качестве способа адресации:

**git diff f292ef5d2b2f6312bc45ae49c2dc14588eef8da2** — найти разницу текущего
состояния проекта и коммита за номером… Ну сами видите, каким.

**git diff f292ef5** — то же самое, но оставляем только шесть первых символов. Git
поймет, о каком коммите идет речь, если не существует другого коммита с таким
началом хэша.

**git diff f292** — иногда хватает и четырех символов.

**git log febc32...f292** — читаем лог с коммита по коммит.

>- **git tag** — тэги как способ пометить уникальный коммит

Тэг (tag) — это объект, связанный с коммитом; хранящий ссылку на сам коммит, имя
автора, собственное имя и некоторый комментарий. Кроме того, разработчик может
оставлять на таких тегах собственную цифровую подпись.

Кроме этого в **git** представленные так называемые «легковесные тэги» («lightweight tags»), состоящие только из имени и ссылки на коммит. Такие тэги, как правило, используются для упрощения навигации по дереву истории; создать их очень легко:

**git tag stable-1** — создать «легковесный» тэг, связанный с последним
коммитом. Если тэг уже есть, то еще один создан не будет.

**git tag stable-2 f292ef5** — пометить определенный коммит.

**git tag -d stable-2** — удалить тег.

**git tag -l** — перечислить тэги.
 <br />
 <br />

### Относительная адресация
 <br />

 Вместо ревизий и тэгов в качестве имени коммита можно опираться на еще один
механизм — относительную адресацию. Например, можно обратиться прямо к предку
последнего коммита ветки **master**:

**git diff master^**

Если после «птички» поставить цифру, то можно адресоваться по нескольким предкам
коммитов слияния:

**git diff HEAD^2** — найти изменения по сравнению со вторым предком последнего
коммита в master. **HEAD** здесь — указатель на последний коммит активной ветки.

>- **файл .gitignore** — объясняем **git**, какие файлы следует игнорировать.

Иногда по директориям проекта встречаются файлы, которые не хочется постоянно
видеть в сводке git status. Например, вспомогательные файлы текстовых
редакторов, временные файлы и прочий мусор.

Заставить git status игнорировать можно, создав в корне или глубже по дереву
(если ограничения должны быть только в определенных директория) файл
.gitignore. В этих файлах можно описывать шаблоны игнорируемых файлов
определенного формата.

Пример содержимого такого файла:

---------------

#комментарий к файлу .gitignore

#игнорируем сам .gitignore

.gitignore

#все html-файлы…

*.html

#… кроме определенного


!special.html


#не нужны объектники и архивы

*.[ao]

--------------

## **«Вместе мы — сила», или основы работы с удаленным репозитарием**
 <br />

### Удаленные ветки (remote tracking branches)
 <br />

Новое понятие здесь — удаленные ветки. Удаленные ветки соответствуют какой-либо
ветке (чаще master) на удаленном сервере. Одна такая создается автоматически при
создании копии удаленного репозитария; все команды, связанные с удаленной
работой, будут по умолчанию использовать именно эту удаленную ветку (обычно
называется «origin»).

>- **git clone** — создание копии (удаленного) репозитария

Для начала работы с центральным репозитарием, следует создать копию
оригинального проекта со всей его историей локально:

**git clone /home/username/project myrepo** — клонируем репозитарий с той же машины в директорию myrepo.

**git clone ssh://user@somehost:port/~user/repository** — клонируем репозитарий,
используя безопасный протокол ssh (для чего требуется завести у себя на машине
эккаунт ssh).

**git clone git://user@somehost:port/~user/repository/project.git/** — у **git** имеется и собственный протокол.

>- **git fetch и git pull** — забираем изменения из центрального репозитария (из удаленной ветки)

**git fetch** — забрать изменения удаленной ветки из репозитария по умолчания,
основной ветки; той, которая была использована при клонировании
репозитария. Изменения обновят удаленную ветку (remote tracking branch), после
чего надо будет провести слияние с локальной ветку командой git merge.

**git fetch /home/username/project** — забрать изменения из определенного
репозитария.

ДОБАВИЛ РАНДОМНЫЙ ТЕКСТ В СЕРЕДИНУ

ДОБАВИЛ РАНДОМНЫЙ ТЕКСТ В СЕРЕДИНУ

ДОБАВИЛ РАНДОМНЫЙ ТЕКСТ В СЕРЕДИНУ

ДОБАВИЛ РАНДОМНЫЙ ТЕКСТ В СЕРЕДИНУ

>- **git push** — вносим изменения в удаленный репозитарий (удаленную ветку)

После проведения работы в экспериментальной ветке, слияния с основной,
необходимо обновить удаленный репозитарий (удаленную ветку). Для этого
используется команда git push:

**git push** — отправить свои изменения в удаленную ветку, созданную при
клонировании по умолчанию.

**git push ssh://yourserver.com/~you/proj.git master:experimental** — отправить изменения из ветки **master** в ветку **experimental** удаленного репозитария.

**git push origin :experimental** — в удаленном репозитарии **origin** удалить ветку **experimental**.

**git push origin master:master** — в удаленную ветку **master** репозитария **origin** (синоним репозитария по умолчанию) ветки локальной ветки **master**.

## **Git-о-день**

В этом разделе будут показаны и разобраны подробно несколько обычных и чуть
меньше необычных для работы с git ситуаций.

### Обычный workflow при работе с локальным репозитарием
 <br />

 **Git** обладает необычайной легкостью в использовании не только как распределенная система контроля версий, но и в работе с локальными проектами. Давайте разберем обычный цикл — начиная с создания репозитария — работы разработчика git над собственным персональным проектом:

>mkdir git-demo <br />
>cd git-demo <br />
>git init
>git add. <br />
>git commit -m «initial commit» <br />
>git branch new-feature <br />
>git checkout new-feature<br />
>git add.<br />
>git commit -m «Done with the new feature»<br />
>git checkout master<br />
>git diff HEAD new-feature<br />
>git merge new-feature<br />
>git branch -d new-feature<br />
>git log --since=«1 day»<br />


Разберем каждое из действий:

1-2 — просто создаем рабочую директорию
проекта. 

3 — создаем репозитарий в директории. 

4 — индексируем все существующие
файлы проекта (если, конечно, они вообще были). 

5 — создаем инициализирующий
коммит. 

6 — новая ветка, 

7 — переключение в нее (можно сделать в один шаг
командой git checkout -b new-feature). Далее, после непосредственной работы с
кодом, индексируем внесенные изменения(8), совершаем коммит(9). Переключаемся в
основную ветку(10), смотрим отличия между последним коммитом активной ветки и
последним коммитом экспериментальной (11). Проводим слияние (12) и, если не было
никаких конфликтов, удаляем ненужную больше ветку (13). Ну и на всякий случай
оценим проведенную за последний день работу (14).

Почему именно так? Зачем отказываться от линейной модели? Хотя бы даже потому,
что у программиста появляется дополнительная гибкость: он может переключаться
между задачами (ветками); под рукой всегда остается «чистовик» — ветка
master; коммиты становятся мельче и точнее.
<br />

### Workflow при работе с удаленным репозитарием <br />
<br />

>git clone http://yourserver.com/~you/proj.git… возможно, прошло некоторое время.<br /> 
>git pull <br />
>git diff HEAD^<br />
>git checkout -b bad-feature… работаем некоторое время.<br />
>git commit -a -m «Created a bad feature»<br />
>git checkout master<br />
>git pull<br />
>git merge bad-feature<br />
>git commit -a<br />
>git diff HEAD^ … запускаем тесты проекта, обнаруживаем, что где-то произошла ошибка. Упс.<br />
>git reset --hard ORIG_HEAD<br />
>git checkout bad-feature… исправляем ошибку.<br />
>git -m bad-feature good-feature<br />
>git commit -a -m «Better feature»<br />
>git checkout master<br />
>git pull<br />
>git merge good-feature<br />
>git push<br />
>git branch -d good-feature<br />

Итак, первым делом создаем (1) копию удаленного репозитария (по умолчанию команды вроде *git pull и git push* будут работать с ним). «Вытягиваем» последние обновления (2), смотрим, что же изменилось(3),  создаем новую ветвь ипереключаемся в нее (4), индексируем все изменения и одновременно создаем из них коммит (5). Переключаемся в главную ветвь (6), обновляем ее (7) проводим слияние с веткой bad-feature(8) и, обнаружив и разрешив конфликт, делаем коммит слияния (9).<br />

После совершения коммита отслеживаем изменения(10), запускаем, например,
юнит-тесты и с ужасом обнаруживаем, что после слияния проект валится на большей
части тестов.<br />

В принципе, тесты можно было прогнать и до коммита, в момент
слияния (между пунктами 8 и 9); тогда бы хватило «мягкого» резета.<br />

Таким образом, приходится совершить «жесткий» (11) сброс произошедшего слияния,
ветки вернулись в исходное до состояние. После чего переключаемся в неудачную
ветку (12), вносим необходимые изменения и переименовываем ветку (13). Совершаем
коммит (14); переходим в главную ветку(15), опять ее обновляем (16). На этот раз
бесконфликтно делаем слияние (17), закидываем изменения в удаленный репозитарий
(18) и удаляем ненужную теперь ветку (19).<br />


# **Нагло взято с Хабра: https://habr.com/ru/post/60347/**

Дополняем таблицами нашу инструкцию: 

| Частота упоминаний | Частота цитирования | Частота частот |
|:-------------------|:-------------------:|---------------:|
|14|99|88|

И ещё одну: 

| Наименование | Частота цитирования | Частота частот |
|:-------------------|:-------------------:|---------------:|
|Мем 1 |99|88|
|Мем 2 |55|866|
|Мем 3 |13|77|

В ресторане PLOV.Project самый вкусный плов
Плов - самое вкусное блюдо
